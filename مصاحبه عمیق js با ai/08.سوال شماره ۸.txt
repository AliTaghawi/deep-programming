# سوال شماره ۸ (همون سوال 2 یه طرز دیگه)

توضیح بده ارث‌بری پروتوتایپی (Prototypal Inheritance) در جاوااسکریپت چگونه کار می‌کند. در پاسخ‌ات حتما به این نکات بپرداز:

- تفاوت بین `prototype` (صفت موجود روی تابع سازنده) و `__proto__` (ارجاع شیء به پروتوتایپش) چیست  
- چطور زنجیرهٔ پروتوتایپ (prototype chain) روی عملیات‌هایی مثل دسترسی به پراپرتی و فراخوانی متد اثر می‌گذارد  
- نقش عملگر `new` در ساختن شیء و اتصال آن به پروتوتایپ تابع سازنده  
- چالش‌ها و موارد کاربرد: وقتی باید از کلاس ES6 استفاده کرد و چه مزایایی دارد نسبت به الگوی سنتی  
- چگونه می‌توان با `Object.create()` یک زنجیرهٔ پروتوتایپی ساده ساخت  
- مشکلات متداول (مثل Override ناخواسته یا تداخل پراپرتی‌های مشترک)

وقتی جواب دادی، درصد عمق و دقت پاسخ‌ت رو می‌دم، نقاط قوت و ضعف‌ش رو اشاره می‌کنم و بعد پاسخ مرجع و کامل رو در اختیارت می‌گذارم. آماده‌ای؟



------------//////////////////////////////////////////
# ارزیابی پاسخ شما برای سوال هشتم: ارث‌بری پروتوتایپی

نمره (عمق و دقت):  Fifty percent 50%

نقاط قوت  
- درک این موضوع که برای اضافه کردن پراپرتی مشترک به تمام نمونه‌ها، باید از `Car.prototype` استفاده کرد  
- تشخیص نقش `__proto__` در اشاره به پروتوتایپ والد  
- توضیح صحیح روند جستجوی پراپرتی در زنجیرهٔ پروتوتایپی  
- اشاره به عملکرد کلیدواژه‌ی `new` در ساختن شیء و اختصاص پروتوتایپ  

نقاط ضعف  
- توضیح مختصر و فقدان جزئیات درونیاتی:  
  - جزییات اینکه چگونه `new` یک شیء خالی می‌سازد، `this` را تنظیم می‌کند و در نهایت آن را برمی‌گرداند  
  - فرق دقیق بین `prototype` (صفت تابع) و `__proto__` (صفت هر شیء)  
- نپرداختن به روش استفاده از `Object.create()`  
- نبود مثال روشن از مشکلِ پراپرتی‌های مشترک (مثل ارجاعات مرجع‌گونه)  
- اشاره‌ی سطحی به کلاس‌های ES6 بدون توضیح نحوه‌ی پیاده‌سازی زیرین  
- غفلت از روش‌های صحیح Override و جلوگیری از تداخل پراپرتی  

---

# پاسخ مرجع و عمیق: ارث‌بری پروتوتایپی در جاوااسکریپت

## ۱. تفاوت `prototype` و `__proto__`
- تابع سازنده (Constructor Function) در JS خود یک شیء است و دارای صفت داخلی `prototype` می‌باشد.  
  ```javascript
  function Car() { /* ... */ }
  console.log(typeof Car.prototype); // "object"
  ```
- هر شیء ساخته‌شده با `new Car()` یک صفت داخلی به نام `__proto__` (یا در استاندارد: `[[Prototype]]`) دارد که به همان `Car.prototype` اشاره می‌کند.  
  ```javascript
  const car1 = new Car();
  console.log(car1.__proto__ === Car.prototype); // true
  ```

## ۲. زنجیرهٔ پروتوتایپی (Prototype Chain)
- وقتی در `car1.someProp` جستجو می‌کنید و `someProp` در خودِ `car1` وجود نداشته باشد، موتور JS به ترتیب:  
  1. `car1.__proto__`  
  2. `car1.__proto__.__proto__`  
  3. و … تا برسد به `Object.prototype.__proto__` که مقدارش `null` است.  
- در لحظه‌ی فراخوانی متد هم به همین زنجیره رجوع می‌شود.

## ۳. نقش `new`  
فراخوانی `new Car(arg1, arg2)` معادل مراحل زیر است:  
1. ایجاد یک شیء خالی با internal `[[Prototype]] = Car.prototype`.  
2. فراخوانی `Car` با `this` اشاره‌گر به آن شیء جدید.  
3. اگر تابع `Car` مقدار شیء نگشت (یعنی `return` نداد)، خودِ شیء ساخته‌شده را برمی‌گرداند.

## ۴. پیاده‌سازی با `Object.create()`
گاهی به‌جای تابع سازنده می‌توان مستقیماً زنجیره ساخت:
```javascript
const proto = { greet() { console.log('hello'); } };
const obj = Object.create(proto);
obj.greet(); // 'hello'
```
اینجا `obj.__proto__ === proto`.

## ۵. کلاس‌های ES6
زیرِ کار کلاس‌ها همچنان از پروتوتایپ استفاده می‌شود:
```javascript
class Car {
  constructor(name) { this.name = name; }
  drive() { console.log(this.name + ' is driving'); }
}
```
معادل Vanilla JS:
```javascript
function Car(name) { this.name = name; }
Car.prototype.drive = function() { console.log(this.name + ' is driving'); };
```
مزیت کلاس‌ها:  
- نگارش قابل‌فهم‌تر  
- پشتیبانی از `extends` و متد `super()`  

## ۶. تداخل پراپرتی‌های مشترک و Override
- اگر یک پراپرتی مرجع‌گونه (مثل آرایه یا شیء) روی پروتوتایپ قرار دهید، همه نمونه‌ها آن را به اشتراک می‌گذارند:
  ```javascript
  function Bag() {}
  Bag.prototype.items = [];
  const b1 = new Bag(), b2 = new Bag();
  b1.items.push('apple');
  console.log(b2.items); // ['apple'] ← غیرمنتظره
  ```
- راهکار: تعریف پراپرتی مرجع در داخل سازنده:
  ```javascript
  function Bag() { this.items = []; }
  ```

---

این پاسخ، تصویر کامل‌تری از ارث‌بری پروتوتایپی، زنجیرهٔ lookup، نقش `new` و مزایا/چالش‌هایش را نشان می‌دهد. اگر مثال‌های بیشتری می‌خواهی یا بخواهی نحوه‌ی ترکیب ES6 کلاس‌ها با متدهای static و private fields را بررسی کنیم، بگو تا عمیق‌تر پیش برویم!
