# سوال شماره ۱۳

توضیح بده مفهوم Debouncing و Throttling در فرانت‌اند چیست و چه تفاوت‌هایی با هم دارند. در پاسخ‌ات حتماً به این نکات بپرداز:

- نحوه کارکرد Debounce (اجرای تابع بعد از مدت معینی از عدم فراخوانی)  
- نحوه کارکرد Throttle (اجرای تابع در فواصل زمانی مشخص)  
- پیاده‌سازی پایه با JavaScript (تابع‌های کمکی ساده)  
- مثال‌های کاربردی (مثل رویداد scroll, resize, input)  
- مزایا، معایب و زمان مناسب استفاده از هر کدام  
- نکات عملکردی و memory leak احتمالی  

منتظرم جواب‌ت رو بشنوم!




----------------///////////////////////////

# Debouncing و Throttling چیست؟

در فرانت‌اند وقتی تابعی به‌طور پر تکرار (مثل رویداد `scroll` یا `input`) فراخوانی می‌شود، بدون کنترل می‌تواند منجر به کاهش کارایی و مصرف بیش از حد حافظه شود. دو الگوی مرسوم برای کاهش این فراوانی «Debouncing» و «Throttling» هستند.

---

## ۱. Debounce

Debouncing یعنی «تمهید» کردن فراخوانی: تابع هدف فقط زمانی اجرا می‌شود که پس از آخرین فراخوانی یک **مدت ثابت** (delay) بگذرد و فراخوانی جدیدی صورت نگیرد.  

- نحوه کار:
  1. هر بار تابع debounced فراخوانی شود، یک `setTimeout` جدید راه‌اندازی می‌شود.  
  2. اگر قبل از اتمام `delay` فراخوانی دوباره رخ دهد، تایمر قبلی با `clearTimeout` لغو می‌شود.  
  3. در نهایت وقتی `delay` به پایان برسد، تابع اجرا می‌شود.

### پیاده‌سازی ساده

```javascript
function debounce(fn, delay = 300) {
  let timerId;
  return function(...args) {
    clearTimeout(timerId);
    timerId = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

### مثال کاربردی

- جستجوی زنده (live search): درخواست API تنها وقتی کاربر برای 500 میلی‌ثانیه تایپ نکند ارسال شود.
- واکشی داده پس از توقف تایپ در فرم.

```javascript
const onSearch = debounce(query => {
  fetch(`/api/search?q=${query}`).then(...);
}, 500);

inputElement.addEventListener('input', e => onSearch(e.target.value));
```

---

## ۲. Throttle

Throttling یعنی «نخستن» فراخوانی: تابع هدف در **فواصل زمانی ثابت** (interval) حداکثر یک‌بار اجرا می‌شود، حتی اگر فراخوانی‌های متوالی زیادی اتفاق بیفتد.

- نحوه کار:
  1. وقتی تابع throttled برای اولین بار فراخوانی شود، اجرا انجام می‌شود و یک پرچم (flag) فعال می‌گردد.  
  2. تا زمانی که آن پرچم فعال است، فراخوانی‌های بعدی نادیده گرفته می‌شوند.  
  3. پس از پایان `interval`، پرچم غیرفعال شده و تابع دوباره اجازه اجرا پیدا می‌کند.

### پیاده‌سازی ساده

```javascript
function throttle(fn, interval = 300) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

### مثال کاربردی

- رویداد `scroll`: به‌جای صدها بار در ثانیه، مثلاً هر 100 میلی‌ثانیه یک‌بار اجرا.
- اندازه‌گیری ابعاد در `resize`: پردازش تغییر اندازه پنجره هر 200 میلی‌ثانیه.

```javascript
const onScroll = throttle(() => {
  console.log(window.scrollY);
}, 100);

window.addEventListener('scroll', onScroll);
```

---

## ۳. مقایسه Debounce و Throttle

| ویژگی                 | Debounce                               | Throttle                      |
|------------------------|----------------------------------------|-------------------------------|
| زمان اجرا              | فقط پس از پایان بازه‌ی بدون فراخوانی  | حداکثر یک بار در هر بازه‌ی مشخص |
| مناسب برای            | جستجوی زنده، **فیلترکردن** ورودی‌ها  | پیمایش (scroll)، تغییر اندازه (resize) |
| رفتار در شروع فراخوانی | اجرا **پس از** سکوت کاربر             | اجرا **بلافاصله** و سپس محدود |
| استفاده معمول         | جلوگیری از ارسال درخواست‌های مکرر API | کنترل نرخ به‌روزرسانی‌های UI  |

---

## ۴. نکات عملکردی و جلوگیری از Memory Leak

- در هر دو الگو:
  - **پاک‌سازی** به‌موقع تایمرها (`clearTimeout`) یا پرچم‌ها اهمیت دارد.  
  - اگر المانی که listener به آن متصل است از DOM حذف شد، حتماً listener را با `removeEventListener` بردارید تا نشتی حافظه رخ ندهد.
- در React:
  - داخل `useEffect` تایمرها را تنظیم و در cleanup آن‌ها را فسخ کنید.

---

با این دو تکنیک می‌توانید کنترل دقیقی روی فراوانی اجرای توابع پر مصرف داشته باشید و کارایی اپلیکیشن‌های فرانت‌اند را به‌طرز محسوسی بهبود بخشید.
