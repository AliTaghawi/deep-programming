# سوال شماره ۷

توضیح بده مفهوم Event Delegation در فرانت‌اند چیست و چه مزیت‌هایی دارد. در پاسخ‌ات حتما به این نکات بپرداز:

- چطور می‌توان با یک listener روی المان والد، به جای افزودن listener به هر فرزند، اتفاقات کلیک/کی‌پرس و… را مدیریت کرد  
- نحوه استفاده از `event.target` و `event.currentTarget` برای تشخیص منبع واقعی رویداد  
- مزایای کارایی و مدیریت حافظه (performance & memory)  
- موارد کاربرد رایج (مثل لیست‌های داینامیک، گالری تصاویر)  
- نکات و تله‌های احتمالی (مثل مشکل رویدادهای مشارکتی، جلوگیری از اجرا شدن unintended handlers)  

وقتی جواب دادی درصد عمق و دقت پاسخ‌تو می‌دم و در نهایت پاسخ مرجع رو در اختیارت می‌گذارم. آماده‌ای؟



-----///////////////////////////////////////

# سوال شماره ۷: Event Delegation در فرانت‌اند

Event Delegation تکنیکی است که به‌جای افزودن listener به هر المان فرزند، یک listener را روی المان والد یا حتی `document` می‌گذاریم تا رویدادها (مثل کلیک، کی‌پرس و…) از طریق «بابلینگ» به آن منتقل شوند و آنجا مدیریت شوند.

---

## ۱. نحوه پیاده‌سازی

- انتخاب یک عنصر والد (مثلاً یک `<ul>` یا `<div>` کلی)  
- ثبت یک listener واحد روی آن  
- استفاده از `event.target` برای تشخیص المان واقعی که رویداد را تحریک کرده  
- مثال:
  ```html
  <ul id="todo-list">
    <li data-id="1">کار اول</li>
    <li data-id="2">کار دوم</li>
  </ul>

  <script>
    const list = document.getElementById('todo-list');
    list.addEventListener('click', e => {
      const item = e.target.closest('li');
      if (!item) return;
      console.log('کلیک روی آیتم', item.dataset.id);
    });
  </script>
  ```

---

## ۲. `event.target` vs `event.currentTarget`

- `event.target`  
  المانی است که واقعی کلیک یا رویداد را به‌وجود آورده (مثلاً یک `<span>` درون `<li>`).

- `event.currentTarget`  
  عنصری که listener روی آن نصب شده (مثلاً همان `<ul id="todo-list">`).

| ویژگی              | event.target               | event.currentTarget         |
|---------------------|----------------------------|-----------------------------|
| منبع اولیه رویداد  | المان واقعی که کلیک شده   | عنصری که listener نصب شده  |
| تغییر در delegation | مهم برای تشخیص فرزند مورد نظر | ثابت می‌ماند               |

---

## ۳. مزایای Performance و Memory

- کاهش تعداد listenerها در DOM و در نتیجه کاهش حافظه مصرفی  
- کمتر کردن overhead در فراخوانی‌های متعدد callback  
- ساده‌تر شدن مدیریت افزودن/حذف آیتم‌های داینامیک  
- بهبود کارایی در لیست‌های طولانی یا جدول‌های پویا  

---

## ۴. موارد کاربرد رایج

- مدیریت رخدادهای لیست‌های داینامیک (`<ul>`, `<table>`)  
- گالری تصاویر که می‌توانند آیتم اضافه یا حذف شوند  
- فرم‌های پیچیده با فیلدهای تکرارشونده  
- منوهای دراپ‌داون یا context menu با آیتم‌های پویا  

---

## ۵. تله‌ها و نکات احتیاطی

- **بابلینگ غیرمنتظره**: بعضی رویدادها بابلینگ نمی‌کنند (مثل `focus`/`blur`)  
- **stopPropagation**: اگر یکی از listenerهای فرزند `stopPropagation()` صدا بزند، نمی‌توانید آن رویداد را در والد بگیرید  
- **شناسایی درست هدف**: استفاده از `closest()` یا چک کردن مشخصه‌ها (`data-` attributes) برای جلوگیری از گرفتن کلیک روی المان‌های نامرتبط  
- **کار با capture vs bubble**: می‌توانید سومین آرگومان `addEventListener` را `{ capture: true }` قرار دهید تا در فاز capture هم شنونده باشید  

---

اگر دوست داری مثالی تعاملی با کدهای عملی یا بررسی رفتار event delegation در فریم‌ورک‌هایی مثل React یا Vue ببینیم، یا بخواهی وارد موضوع مدیریت state در کنار delegation بشویم، خبر بده!
