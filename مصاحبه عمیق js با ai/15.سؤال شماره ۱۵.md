# سؤال شماره ۱۵

توضیح بده مدل اجرای هم‌زمان (Concurrency Model) در جاوااسکریپت چگونه کار می‌کند. در پاسخ‌ات حتماً به این نکات بپرداز:

- ساختار Call Stack و چرخهٔ Event Loop  
- تفاوت بین Microtask Queue (مثل Promise callbacks) و Macrotask Queue (مثل `setTimeout`/`setInterval`)  
- ترتیب اجرای وظایف (tasks) در یک tick از Event Loop  
- مثال‌هایی از چالش‌های معروف (مثل استال کردن UI یا ترتیب نامشخص اجرای callbackها)  
- تأثیر روی عملکرد و بهترین الگوها برای نوشتن کد غیرهم‌زمان  

منتظر جوابت هستم!  



------------------//////////////////////// 
# مدل اجرای هم‌زمان (Concurrency Model) در جاوااسکریپت

جاوااسکریپت تک‌ریسمانی (single-threaded) است؛ یعنی در هر لحظه فقط یک دستور روی **Call Stack** اجرا می‌شود. اما قابلیت غیرهم‌زمان بودن (asynchronous) و هم‌زمان‌سازی ظاهری را از طریق **Event Loop**، **Macrotask Queue** و **Microtask Queue** فراهم می‌کند.

---

## ساختار Call Stack و Event Loop

- Call Stack  
  هر فراخوانی تابع، روی یک پشته (stack) قرار می‌گیرد. اجرا تا وقتی ادامه دارد که پشته خالی شود.  

- Event Loop  
  موتور جاوااسکریپت مرتباً این مراحل را تکرار می‌کند:  
  1. اگر Call Stack خالی باشد،  
  2. یک تسک (task) از **Macrotask Queue** بیرون می‌کشد، اجرا می‌کند،  
  3. سپس **تمام** میکروتسک‌ها را از **Microtask Queue** اجرا می‌کند،  
  4. در پایان یک فریم رندر (paint) ممکن است انجام شود.

---

## تفاوت Macrotask و Microtask

| ویژگی                    | Macrotask                             | Microtask                             |
|---------------------------|---------------------------------------|---------------------------------------|
| نمونه‌ها                  | `setTimeout`, `setInterval`, I/O      | Promise callbacks (`.then/.catch`), `MutationObserver` |
| صف (Queue)                | Macrotask Queue                       | Microtask Queue                       |
| زمان اجرا                 | یک به یک در ابتدای هر تکرار Event Loop | پس از اتمام هر تسک و قبل از رفتن سراغ تسک بعدی |
| اولویت                    | کمتر (اجرا بعد از میکروتسک‌ها)        | بیشتر (بلافاصله پس از تسک)            |

---

## ترتیب اجرای وظایف در یک tick

1. اجرای تمام کد سینکرون روی Call Stack  
2. خالی شدن Call Stack  
3. برداشتن یک تسک از Macrotask Queue و اجرای آن  
4. اجرای **تمام** میکروتسک‌های صف Microtask  
5. یکبار رندر مجدد (در صورت نیاز)  
6. تکرار از قدم 3  

---

## مثال از تفاوت `setTimeout` و `Promise`

```javascript
console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve()
  .then(() => console.log('promise'));

console.log('end');
```

ترتیب خروجی:
```
start
end
promise   ← میکروتسک
timeout   ← ماکروتسک
```

---

## چالش‌های رایج

- **UI Blocking**  
  اگر کد سنگینی روی Call Stack اجرا شود (حلقه‌ها یا محاسبات بزرگ)، ردگیری Event Loop متوقف و رابط کاربری فریز می‌شود.  

- **Starvation**  
  در صورتی که تعداد زیادی میکروتسک پشت سر هم تولید شوند، ممکن است تسک‌های ماکرو (مثل `setTimeout`) دیر یا اصلاً اجرا نشوند.  

- **ترتیب نامشخص**  
  ترکیب چند منبع رویداد (I/O، timer، promise) گاهی می‌تواند منجر به ترتیب غیرقابل پیش‌بینی اجرای callbackها شود.

---

## بهترین الگوها برای کد غیرهم‌زمان

- **تقسیم کار سنگین**  
  - کارهای محاسباتی بزرگ را بخش‌بندی کنید یا به Web Worker بسپارید.  
- **استفاده از async/await**  
  - خواناتر است و با میکروتسک‌ها کار می‌کند.  
- **محدود کردن میکروتسک‌ها**  
  - از زنجیره‌های طولانی `then` خودداری کنید تا از starvation جلوگیری شود.  
- **Throttle/Debounce** در رویدادهای پر تکرار  
  - جلوی فریز شدن UI را می‌گیرد.  
- **رندر قطعه‌ای**  
  - کارهای زیاد را میان فریم‌های رندر پخش کنید (مثلاً با `requestIdleCallback` یا تقسیم دستی).

---

با این ساختار می‌توانید بفهمید چرا `Promise`ها پیش از `setTimeout` اجرا می‌شوند، چطور از بلاک شدن رابط کاربری جلوگیری کنیم و بهترین شیوه‌ها برای نوشتن کد غیرهم‌زمان در جاوااسکریپت چیست.
