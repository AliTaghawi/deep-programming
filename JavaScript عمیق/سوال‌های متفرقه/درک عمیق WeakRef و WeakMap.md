# درک عمیق WeakRef و WeakMap در جاوااسکریپت

Garbage Collector‌ (GC) در جاوااسکریپت رفرنس‌های زنده (reachable) را نگه می‌دارد و بقیه را آزاد می‌کند.  
WeakRef و WeakMap ابزارهایی هستند تا رفرنس‌هایی ایجاد کنیم که به‌صورت «ضعیف» نگه داشته شوند و جلوی جمع‌آوری حافظه را نگیرند.  

---

## رفرنس‌های قوی (Strong) در مقابل ضعیف (Weak)

رفرنس قوی یعنی وقتی متغیری به شیئی اشاره می‌کند، GC آن شیء را حذف نمی‌کند تا رفرنس برداشته شود.  
رفرنس ضعیف اجازه می‌دهد حتی اگر در ساختاری باشند، شیء باقیمانده توسط GC آزاد شود وقتی رفرنس قوی دیگری وجود نداشته باشد.  
این مکانیزم برای جلوگیری از نشت حافظه (memory leaks) در ساختارهای پیچیده بسیار مفید است.  

---

## WeakMap چیست؟

- ساختاری شبیه Map معمولی اما کلیدها ضعیف هستند.  
- اگر هیچ رفرنس قوی دیگری به کلید (کلید باید از نوع شیء باشد) وجود نداشته باشد، آن جفت کلید–مقدار آزاد می‌شود.  
- برای پیوستن داده جانبی (metadata) به اشیاء بدون نگرانی از نشتی حافظه مناسب است.  

```js
const wm = new WeakMap();

(function() {
  let user = { id: 42 };
  wm.set(user, { lastAccess: Date.now() });
  // وقتی این بلاک به پایان برسد، user کاربردی ندارد
})();

// چون هیچ رفرنس قوی به شیء user نیست، entry مربوطه در اولین دوره GC حذف می‌شود
```

---

## WeakRef چیست؟

- ابزاری جدید (ES2021) برای نگهداری رفرنس ضعیف به یک شیء.  
- با استفاده از `deref()` می‌توان به شیء دسترسی پیدا کرد یا `undefined` دریافت کرد اگر آزاد شده باشد.  
- معمولاً با `FinalizationRegistry` همراه می‌شود تا وقتی شیء آزاد شد، callback اجرا شود.

```js
const registry = new FinalizationRegistry(token => {
  console.log('شیء آزاد شد:', token);
});

(function() {
  let bigObj = { data: new Array(1000000).fill('*') };
  const weak = new WeakRef(bigObj);
  registry.register(bigObj, 'bigObj');
  bigObj = null; // رفرنس قوی حذف شد
  // حالا وقتی GC اجرا شود، bigObj آزاد شده و callback فراخوانی می‌شود
})();
```

---

## مقایسه کلی

| ویژگی                | WeakMap                         | WeakRef                          |
|-----------------------|---------------------------------|----------------------------------|
| کلید/رفرنس            | کلید باید شیء و ضعیف باشد       | نگهداری ضعیف یک رفرنس به شیء    |
| دسترس‌پذیری مقادیر    | `get(key)` تا زمانی که زنده باشد | `deref()` یا `undefined`         |
| حذف خودکار در GC      | بله                             | بله                              |
| API جانبی             | ساده (set/get/delete)           | همراه با FinalizationRegistry    |

---

## موارد کاربرد

- ذخیره metadata برای اشیاء دم‌دستی (DOM، مدل‌ها، event listener)  
- پیاده‌سازی cache با حذف خودکار ورودی‌های بلااستفاده  
- مدیریت منابع سنگین (مثل بافرها، تصاویر)  
- طراحی معماری publish/subscribe با cleanup خودکار  

---

## نکات و هشدارها

- نباید به‌جای weak ساختارهای قوی (مثل Map عادی) استفاده کنید؛ تنها وقتی برای جلوگیری از نشتی نیاز است.  
- `FinalizationRegistry` تضمین قطعی فراخوانی callback را نمی‌دهد و زمان‌بندی آن مشخص نیست.  
- دسترسی مکرر به `deref()` یا بررسی زنده بودن رفرنس مضاعف پیچیدگی منطقی ایجاد می‌کند.  
- پشتیبانی مرورگرها را قبل استفاده بررسی کنید (بیشتر مرورگرهای مدرن از این APIها پشتیبانی می‌کنند).  

---

## چشم‌اندازهای مرتبط

- **WeakSet**: مشابه WeakMap ولی فقط نگهداری کلید (شیء)  
- **سایر زبان‌ها**: جاوا، دات‌نت و … نیز مفاهیم مشابهی دارند؛ مقایسه با آنها می‌تواند بینش عمیق‌تری بدهد  
- **الگوریتم‌های GC**: مطالعه عمیق Mark-and-Sweep و Generational GC برای فهم رفتار زمان‌بندی آزادسازی  
- **الگوهای طراحی**: استفاده از weak references در الگوهای memory-sensitive مثل LRU cache  

اگر مایلید به مثال‌های پیچیده‌تر یا بررسی تفاوت رفتار در runtimeهای مختلف بپردازیم، خوشحال می‌شوم ادامه دهم!
