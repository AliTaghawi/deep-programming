# مقایسۀ عمیق Stack و Heap در حافظۀ JavaScript

---

## نمای کلی حافظه

جاوااسکریپت برای نگهداری داده‌ها دو ناحیۀ اصلی حافظه دارد:

- Stack برای ذخیره‌سازی مقادیر Primitive و اشاره‌گرها  
- Heap برای تخصیص پویا و نگهداری اشیاء، آرایه‌ها و توابع  

تفکیک این مناطق محدودیت‌ها و فرصت‌های متفاوتی در عملکرد، دسترسی و مدیریت حافظه ایجاد می‌کند.

---

## Stack: ویژگی‌ها و کاربرد

Stack یک ساختار LIFO است که سریع‌ترین نوع دسترسی را دارد:

- تخصیص و آزادسازی خودکار در زمان خروج از بسته (frame)  
- نگهداری متغیرهای Primitive و اشاره‌گرهای به اشیاء در Heap  
- ظرفیت محدود و معمولاً ثابت برای هر Thread  

تخصیص روی Stack در چند نانوثانیه انجام می‌شود و هنگام اتمام تابع یا بلوک، کامل آزاد می‌گردد.

---

## Heap: ویژگی‌ها و کاربرد

Heap ناحیه‌ای پویا و بزرگ است که برای اشیاء و ساختارهای پیچیده استفاده می‌شود:

- تخصیص در زمان اجرا و آزادسازی توسط Garbage Collector  
- دسترسی نسبتاً کندتر از Stack به‌دلیل جستجوی آدرس‌های پویا  
- پتانسیل Fragmentation در صورت تخصیص و آزادسازی ناپیوسته  

این ناحیه به طور مداوم توسط موتور JavaScript اسکن می‌شود تا شیءهای غیرفعال کشف و پاک شوند.

---

## فرآیند تخصیص و دسترسی

1. هنگام اجرای تابع، یک Execution Context جدید ایجاد می‌شود و روی Stack قرار می‌گیرد.  
2. متغیرهای Primitive مستقیماً در این بسته قرار می‌گیرند.  
3. برای اشیاء، یک آدرس در Heap تخصیص داده شده و اشاره‌گر آن در Stack ذخیره می‌شود.  
4. دسترسی به Primitive از طریق آدرس ثابت و دسترسی به اشیاء با دنبال کردن اشاره‌گر انجام می‌شود.

---

## مدیریت حافظه و Garbage Collection

جاوااسکریپت از الگوریتم Mark-and-Sweep برای پاکسازی Heap بهره می‌برد:

- مرحله Mark: از ریشه‌ها (Roots) نظیر متغیرهای در حال استفاده شروع و اشیاء قابل دسترس نشانه‌گذاری می‌شوند  
- مرحله Sweep: اشیاء بدون نشانه حذف و فضا آزاد می‌شود  
- موتورهای مدرن مانند V8 از تکنیک‌های Generational و Incremental GC برای کاهش Pauseها استفاده می‌کنند  

این مکانیسم اطمینان می‌دهد حافظۀ غیرقابل‌دسترسی به‌تدریج بازپس‌گیری گردد.

---

## تعامل بین Stack و Heap

- متغیرهای Local تابع در Stack نگهداری می‌شوند.  
- اگر یک تابع به شیء‌ای در Heap ارجاع دهد، تا پایان عمر آن ارجاع، شیء زنده می‌ماند.  
- در Closures، حتی پس از خاتمه اجرای تابع والد، بسته‌های مربوط به متغیرها روی Heap نگهداری می‌شوند تا درون تابع فرزند قابل‌دسترسی باشند.  

این تعامل علت اصلی افزایش زمان حیات برخی اشیاء و پیچیدگی مدیریت حافظه در JavaScript است.

---

## چالش‌ها و نکات بهینه‌سازی

- نگهداری رفرنس‌های بدون استفاده (مانند listenerهای DOM) می‌تواند موجب Memory Leak شود.  
- Fragmentation بالای Heap روی مصرف حافظه تأثیر منفی دارد.  
- ابزار Profiling در Chrome DevTools و Node.js با Heap Snapshot به شناسایی نشت کمک می‌کنند.  
- اجتناب از ساخت و نابودسازی مکرر اشیاء بزرگ و استفاده از Object Pooling، سرعت و ثبات عملکرد را افزایش می‌دهد.

---

## جمع‌بندی

Stack با دسترسی سریع و مدیریت خودکار مناسب داده‌های ساده است؛ در حالی که Heap برای ذخیره‌سازی پویا و پیچیده کاربرد دارد. درک نحوه تخصیص و آزادسازی در هر دو بخش، کلید نوشتن کد بهینه، جلوگیری از نشت حافظه و بهبود عملکرد برنامه‌هاست.

---

## بیشتر بدانید

- جزئیات Execution Context و Call Stack در JS  
- الگوهای Immutable برای کاهش Side-Effect  
- Garbage Collectorهای Generational و Incremental در V8  
- نشت حافظه رایج در SPAها و راه‌های پیشگیری  
- ابزارهای پروفایلینگ حافظه در مرورگر و Node.js


-------------------//////////////////////خوب یعنی اون دو حافظه یه جایی توی جاوا اسکریپت هستند یا برای هر تابع و اسکوپ جداگانه درست میشن؟/////////////////////////-----------------------


# نحوهٔ تخصیص Stack و Heap در زمان اجرا

در واقع حافظهٔ Stack و Heap دو ناحیهٔ واحد و همیشگی هستند که موتور JavaScript هنگام شروع اجرا رزرو می‌کند و در کل طول عمر برنامه از آنها استفاده می‌شود. اما هر بار که تابعی فراخوانی می‌شود یا یک Scope جدید شکل می‌گیرد، بخش‌هایی از این حافظه روی همان ناحیهٔ موجود اختصاص می‌یابند و آزاد می‌شوند.

---

## ۱. Stack: یک ناحیهٔ یکتا با فریم‌های تابع

- موتور JS یک Call Stack واحد دارد که به‌صورت LIFO کار می‌کند.  
- وقتی برنامه شروع می‌شود، یک **Global Execution Context** در رأس

# اندازهٔ Stack و Heap در موتور JavaScript

زمانی‌که از «حافظهٔ Stack» و «حافظهٔ Heap» در JavaScript صحبت می‌کنیم، باید به این نکته توجه کنیم که این محدودیت‌ها به پیاده‌سازی موتور (مثلاً V8 در Chrome/Node.js) و معماریِ سخت‌افزار (۳۲ یا ۶۴ بیتی) بستگی دارند. در ادامه محدوده‌های معمول را مرور می‌کنیم.

---

## Stack

- Stack برای نگهداری فریم‌های Execution Context و متغیرهای Primitive/اشاره‌گرها استفاده می‌شود.  
- اندازهٔ پیش‌فرض Stack در V8 (موتور Node.js و کروم) حدود 984 کیلوبایت ( ≈960 KiB) است.  
- در معماری ۶۴ بیتی می‌توان با فلگ `--stack_size` هنگام اجرای Node.js تا چند مگابایت (حدود ۱۶ مگابایت به بالا) آن را تغییر داد.  
- در مرورگر کروم نیز محدودیت مشابهی وجود دارد و هر تَب حدود ۱ مگابایت Stack اختصاص می‌گیرد که در تنظیمات پیشرفته قابل تغییر نیست.

---

## Heap

- Heap برای تخصیص پویا اشیاء، آرایه‌ها و توابع مصرف می‌شود.  
- **Node.js (V8 ۶۴ بیتی):**  
  - حداکثر حدود ۱٫۴ گیگابایت Heap بر حسب پیش‌فرض.  
  - فلگ `--max-old-space-size` این مقدار را تا چند ده گیگابایت می‌تواند ببرد.  
- **Node.js (V8 ۳۲ بیتی):**  
  - حدود ۷۰۰ مگابایت Heap پیش‌فرض.  
- **مرورگر Chrome:**  
  - در هر Tab حدود ۱٫۵ تا ۲ گیگابایت Heap اختصاص می‌دهد.  
  - ممکن است بر اساس مصرف حافظهٔ سیستم و نسخهٔ مرورگر متغیر باشد.

---

## جدول مقایسهٔ حدود حافظه

| پلتفرم / معماری       | Stack (پیش‌فرض)     | Heap (پیش‌فرض)           | فلگ تغییر اندازه        |
|-----------------------|----------------------|---------------------------|--------------------------|
| Node.js ۶۴ بیتی      | ≈984 KiB        | ≈1.4 GiB             | --stack_size<br>--max-old-space-size |
| Node.js ۳۲ بیتی      | ≈984 KiB             | ≈700 MiB                  | همانند ۶۴ بیتی           |
| Chrome (هر Tab)       | ≈1 MiB               | ≈1.5–2 GiB                | ندارد (پنهان)            |

---

## نکات عملی

- افزایش Stack بیش از حد می‌تواند منجر به صفحه‌آرایی ناکارآمد و کاهش عملکرد شود.  
- اگر با Out-Of-Memory در Heap مواجه شدید، استفاده از `--max-old-space-size=SIZE` برای Node.js رایج است.  
- ابزارهایی مثل Chrome DevTools Heap Profiler برای بررسی مصرف و نشت حافظه بسیار کارآمدند.  
- بهینه‌سازی کد جهت کاهش ساخت/ریختن اشیاء بزرگ و استفاده از Object Pooling، فشار روی Heap را کاهش می‌دهد.

---

## منابع

1. Stack Size Limits in V8: Node.js Issue Tracker و مستندات V8 – اندازهٔ پیش‌فرض Stack حدود ۹۸۴ کیلوبایت است  
2. V8 Memory and Garbage Collection Documentation – پیش‌فرض Heap در V8 ۶۴ بیتی حدود ۱.۴ گیگابایت است

