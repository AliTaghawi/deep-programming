# مقایسه عملگرهای == و === در JavaScript

---

## مقدمه

در JavaScript، مقایسهٔ ارزش‌ها به دو صورت اصلی انجام می‌شود:  
- `==` که پیش از مقایسه نوع داده‌ها را به یکدیگر تبدیل می‌کند (Type Coercion)  
- `===` که تنها زمانی `true` برمی‌گرداند که نوع و مقدار دقیقاً برابر باشند (Strict Equality)  

درک رفتار این دو عملگر برای جلوگیری از خطاهای پنهان و نوشتن کد مطمئن اهمیت زیادی دارد.

---

## الگوریتم مقایسه با == (Abstract Equality)

عملگر `==` طبق «Abstract Equality Comparison Algorithm» رفتار می‌کند:

1. اگر نوع‌ها برابر باشند، مقایسهٔ مقدار انجام می‌شود.  
2. اگر یکی `null` و دیگری `undefined` باشد، نتیجه `true` خواهد بود.  
3. در صورت وجود ترکیب عدد و رشته، رشته به عدد تبدیل و سپس مقایسه می‌شود.  
4. در صورت حضور boolean، ابتدا به عدد تبدیل می‌شود (`true → 1`, `false → 0`).  
5. اگر یک طرف شیء باشد و طرف دیگر primitive، شیء با فراخوانی ToPrimitive به مقدار اولیه تبدیل می‌شود.  

این قوانین متنوع باعث بروز نتایج غیرمنتظره مانند `"5" == 5 // true` یا `"" == 0 // true` می‌شوند.

---

## الگوریتم مقایسه با === (Strict Equality)

عملگر `===` رفتار بسیار ساده‌تری دارد:

- ابتدا نوع دو عملوند بررسی می‌شود؛ اگر متفاوت باشند، بلافاصله `false` می‌شود.  
- در صورت یکسان بودن نوع‌ها، مقایسهٔ مقدار دقیق (bitwise) انجام می‌شود.  
- هیچ‌گونه تبدیل نوع (coercion) صورت نمی‌گیرد.  
- نکتهٔ ویژه: `NaN === NaN` نتیجهٔ `false` است و برای این مورد باید از `Number.isNaN()` یا `Object.is()` استفاده کرد.  

این خصیصه باعث می‌شود استفاده از `===` اغلب امن‌تر و پیش‌بینی‌پذیرتر باشد.

---

## جدول مقایسهٔ == در مقابل ===

| ویژگی                           | == (Coercion)                               | === (Strict)                     |
|---------------------------------|---------------------------------------------|----------------------------------|
| تبدیل خودکار نوع                | دارد (رشته→عدد، boolean→عدد، ToPrimitive)    | ندارد                            |
| مقایسهٔ `null` و `undefined`    | برابر می‌شوند                             | متفاوت هستند                    |
| مقایسهٔ رشته و عدد              | رشته به عدد تبدیل و سپس مقایسه می‌شود       | همیشه `false`                   |
| مقایسهٔ شیء                     | مقایسهٔ مرجع پس از ToPrimitive             | مقایسهٔ مرجع بدون تبدیل         |
| سادگی و قابل پیش‌بینی بودن      | پیچیده و مستعد خطا                          | ساده و امن                       |

---

## نکات و بهترین شیوه‌ها

- همیشه در صورت امکان از `===` به‌جای `==` استفاده کنید تا رفتار صریح و بدون تبدیل نوع داشته باشید.  
- اگر نیاز به تشخیص `NaN` دارید، از `Number.isNaN(value)` یا `Object.is(value, NaN)` بهره ببرید.  
- برای مقایسه‌های عمیق‌تر (مثلاً اشیاء تو در تو) از کتابخانه‌هایی مثل Lodash (`_.isEqual`) یا JSON serialization استفاده کنید.  
- در موارد بسیار خاص که تبدیل نوع به نفعتان است، می‌توانید از `==` بهره ببرید؛ اما مستندسازی آن را فراموش نکنید.

---

## بیشتر بدانید

- جزئیات `ToPrimitive` و دیگر متدهای تبدیل در ECMAScript Spec  
- رفتار `Object.is()` و تفاوت‌های ریز آن با `===`  
- مثال‌های عملی در React و Redux برای جلوگیری از رندر مجدد غیرضروری  
- ابزارهای linters (مانند ESLint) برای اجبار به استفاده از مقایسهٔ Strict  
- الگوهای طراحی برای مدیریت وضعیت و مقایسهٔ امن در برنامه‌های بزرگ JavaScript


