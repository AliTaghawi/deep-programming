# Global, Function و Block Scope در JavaScript

در JavaScript هر متغیر یا تابع در یکی از این سه حوزه (Scope) تعریف و قابل دسترسی است. فهم عمیق این حوزه‌ها برای پیشگیری از خطاهای نامعلوم، بهینه‌سازی حافظه و درک بهتر عملکرد Closureها ضروری است.

---

## Global Scope

هر چیزی که در سطح بالای کد (بیرون از هر تابع یا بلوک) تعریف شود در حوزه‌ی سراسری قرار می‌گیرد.

```js
var a = 10;
let b = 20;
const c = 30;

function foo() {
  console.log(a); // 10
}

foo();
console.log(window.a); // 10 — var به window متصل می‌شود
console.log(window.b); // undefined — let/const به window متصل نمی‌شوند
```

ویژگی‌های کلیدی:

- متغیرهای تعریف‌شده با `var` به‌همراه تابع‌ یا بلاک، مستقیماً به شیٔ سراسری (مثلاً `window` در مرورگر) متصل می‌شوند.
- تعریف متغیر بدون کلمه‌ی کلیدی (`x = 5`) در حالت non-strict به‌صورت خودکار متغیر سراسری می‌سازد و خطر درز نام‌ها را افزایش می‌دهد.
- در حالت strict، تولید متغیر سراسری خودکار با خطا مواجه خواهد شد.

---

## Function Scope

هر تابع یک حوزه‌ی مجزا برای متغیرهای تعریف‌شده با `var` فراهم می‌کند. این یعنی این متغیرها تنها داخل همان تابع قابل دستیابی هستند و پیش از اعلان نیز به‌دلیل Hoisting مقدار `undefined` دارند.

```js
function bar() {
  console.log(x); // undefined (hoisted)
  var x = 5;
  console.log(x); // 5
}
bar();
console.log(typeof x); // "undefined"
```

نکات مهم:

- متغیرهای `var` در بالای حوزه‌ی تابع hoist می‌شوند اما بدون مقدار اولیه.
- تابع‌ها (Function Declaration) نیز به‌طور کامل همراه با بدنه‌شان hoist می‌شوند و می‌توان قبل از تعریف از آنها استفاده کرد.
- Arrow Functionها و Function Expressionها تنها در زمان ارزیابی به‌عنوان متغیر معرفی می‌شوند، نه در ابتدای حوزه.

---

## Block Scope

بلوک‌ها شامل تگ‌های `{ … }` در ساختارهایی مثل `if`، `for`، `while` یا بلوک‌های ساده هستند. متغیرهای تعریف‌شده با `let` و `const` داخل بلوک تنها تا پایان همان بلوک زنده‌اند.

```js
{
  let i = 1;
  const j = 2;
  console.log(i, j); // 1 2
}
console.log(typeof i, typeof j); // undefined undefined
```

ویژگی‌های کلیدی:

- متغیرهای `let` و `const` دارای Temporal Dead Zone هستند؛ تا پیش از رسیدن به خط تعریف، نمی‌توان به آنها دسترسی داشت و ارجاع دادن باعث خطا می‌شود.
- هر بلوک جدید محیط جدیدی ایجاد می‌کند. می‌توانید در هر بلوک متغیری با نام مشابه داشته باشید بدون تداخل.
- `var` درون بلوک صِرفاً function-scoped است و بلوک جدید حوزه‌ی جدا ندارد.

---

## مقایسه‌ی var، let و const در حوزه‌ها

| ویژگی               | var                       | let                       | const                        |
|----------------------|---------------------------|---------------------------|------------------------------|
| Hoisting             | بله (undefined)           | بله (TDZ قبل از تعریف)   | بله (TDZ قبل از تعریف)      |
| حوزه                 | Global / Function         | Global / Function / Block | Global / Function / Block    |
| امکان بازتعریف       | بله                       | نه                        | نه                           |
| اتصال به شیٔ سراسری  | بله (در Global)          | نه                        | نه                           |
| مقداردهی پس از تعریف | بله                       | بله                       | خیر                          |

---

## Scope Chain و Closure

وقتی تابعی درون تابع دیگری تعریف شود، تابع داخلی می‌تواند به متغیرهای تابع والد دسترسی داشته باشد. این دسترسی تا زمانی که ارجاع زنده باشد حفظ می‌شود و Closure ایجاد می‌گردد.

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const c1 = outer();
c1(); // 1
c1(); // 2
```

ویژگی‌ها:

- هر بار فراخوانی `outer` یک محیط جدید (Lexical Environment) می‌سازد.
- `inner` به آن محیط دسترسی دائمی دارد؛ حتی بعد از پایان اجرای `outer`.
- Closure پایه‌ی بسیاری از الگوهای طراحی مانند Module Pattern است.

---

## نکات پیشرفته و بهترین شیوه‌ها

- برای جلوگیری از آلودگی حوزه‌ی سراسری، همواره از `let` و `const` استفاده کنید و حالت strict را فعال نمایید.
- در توابع بلند، تغییرات متغیرهای `var` می‌تواند منجر به باگ‌های پیچیده شود؛ دامنه‌های کوچک‌تر و بلوک‌محور به خوانایی و اطمینان‌پذیری کمک می‌کنند.
- از Closure برای کاوش‌های خصوصی‌سازی یا نگهداری وضعیت استفاده کنید؛ اما مراقب حافظه باشید که ماندگاری ناخواسته‌ متغیر را ایجاد نکند.

---

برای تعمیق بیشتر می‌توانید به مبحث اجرای موتور JavaScript (Execution Context & Call Stack) و Garbage Collection مراجعه کنید که در درک نحوه‌ی مدیریت حوزه‌ها و پاک‌سازی حافظه بسیار مؤثرند.
