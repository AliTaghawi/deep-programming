# زنجیرهٔ پروتوتایپ (Prototype Chain) در JavaScript — توضیحی عمیق و جامع

در JavaScript، هر شیء می‌تواند یک مرجع داخلی به شیء دیگری داشته باشد تا در صورت نبود یک پراپرتی در خودش، به دنبال آن در شیء مرجع بگردد. این ارتباط زنجیره‌ای، «زنجیرهٔ پروتوتایپ» نامیده می‌شود و اساس وراثت و اشتراک رفتار در زبان است.

---

## صفت داخلی [[Prototype]] و دسترسی از طریق __proto__

هر شیء یک صفت داخلی، به‌نام `[[Prototype]]` دارد. این صفت در اسکوپ کاربر مستقیم در دسترس نیست، اما:

- ES5 روش‌های استاندارد برای کار با آن تعریف کرد:
  - `Object.getPrototypeOf(obj)` برای خواندن `[[Prototype]]`
  - `Object.setPrototypeOf(obj, proto)` برای تنظیم آن
- در عمل رایج، می‌توان از `__proto__` بهره برد؛ یک property دسترسی (accessor) که روی `Object.prototype` تعریف شده:
  
  ```js
  const animal = { eats: true };
  const rabbit = { jumps: true };
  
  // تنظیم prototype با __proto__
  rabbit.__proto__ = animal;
  
  console.log(rabbit.eats); // true ← از animal به ارث رفته
  ```

نکته‌ها:

- تغییر `__proto__` در زمان اجرا هزینه‌بر است و اغلب باعث کندی می‌شود.
- برای کدهای مدرن توصیه می‌شود از متدهای استاندارد ES5+ استفاده کنید.

---

## چگونگی تشکیل زنجیرهٔ پروتوتایپ

وقتی یک شیء می‌سازید:

1. در **Object Literal** (`{}`) و **new Constructor**، پروتوتایپ به `Constructor.prototype` اشاره می‌کند.
2. در **Object.create(proto)**، با آرگومان اول، `[[Prototype]]` صراحتاً مشخص می‌شود.
3. تابع (Function)ها به‌طور پیش‌فرض پروتوتایپ خود را دارند (`Function.prototype`).

نمونه‌ی زنجیره:

```txt
 rabbit
  ├─ jumps: true         ← پراپرتی خودِ rabbit
  └─ [[Prototype]] ──► animal
                       ├─ eats: true
                       └─ [[Prototype]] ──► Object.prototype
                                            ├─ toString()
                                            └─ hasOwnProperty()
                                            └─ [[Prototype]] ──► null
```

---

## الگوریتم lookup پراپرتی تا Object.prototype

زمانی که کدی مانند `obj.prop` اجرا می‌شود، موتور JS از روش زیر پیروی می‌کند:

1. بررسی «مالکیت مستقیم» (own property):
   - اگر `prop` در `obj` وجود داشته باشد (و قابل خواندن باشد)، مقدار آن بازگردانده می‌شود.
2. در غیر این صورت، `obj.[[Prototype]]` گرفته می‌شود و قدم اول روی آن اجرا می‌شود.
3. این کار تا زمانی تکرار می‌شود که:
   - پراپرتی یافت شود → مقدار برگردد  
   - یا `[[Prototype]]` برابر `null` شود → در این حالت `undefined` برگردانده می‌شود

نمونه‌ی کد:

```js
const grandParent = { a: 1 };
const parent      = Object.create(grandParent);
parent.b = 2;
const child       = Object.create(parent);
child.c = 3;

console.log(child.a); // 1 ← از grandParent
console.log(child.b); // 2 ← از parent
console.log(child.c); // 3 ← از خود child
console.log(child.d); // undefined ← پیدا نشد تا Object.prototype
```

---

## تفاوت در operatorها و متدهای موجود

| عملکرد                    | only own properties | با زنجیرهٔ پروتوتایپ | نکته                                   |
|---------------------------|---------------------|-----------------------|----------------------------------------|
| `obj.hasOwnProperty(key)` | بله                 | خیر                   | بررسی فقط در خودِ شیء                  |
| `key in obj`              | خیر                 | بله                   | جستجو تا انتهای زنجیره                |
| `Object.keys(obj)`        | بله                 | خیر                   | فقط پراپرتی‌های قابل شمارش خودِ شیء    |
| `for...in`                | خیر                 | بله                   | پراپرتی‌های enumerable در کل زنجیره   |

---

## نکات ریز و پیچیدگی‌ها

- **shadowing**: وقتی پراپرتی‌ای در پروتوتایپ وجود دارد و در شیء اصلی بازتعریف شود، پراپرتی اصلی ارجحیت دارد.
- **ویرایش runtime**: اضافه یا حذف پراپرتی در پروتوتایپ بر همهٔ فرزندان تأثیر می‌گذارد.
- **مدیریت عملکرد**: 
  - یک زنجیرهٔ کوتاه‌تر سریع‌تر است.
  - تغییر `[[Prototype]]` بعد از ساخت شیء، بهینه‌سازی JIT را بر هم می‌زند.
- **حلقهٔ پروتوتایپی**: اگر به اشتباه پروتوتایپ طوری تنظیم شود که در زنجیره بازگشتی باشد، مشکلات بی‌پایانی رخ می‌دهد.
- **طراحی API**: معمولاً بهتر است به‌جای دستکاری مستقیم پروتوتایپ، از **کلاس‌ها** یا **Object.create** با پروتوتایپ مشخص استفاده کنید.

---

## بهترین شیوه‌ها

- برای وراثت ساده، از کلاس‌ها (`class`/`extends`) یا `Object.create` استفاده کنید.
- از تغییر `__proto__` پس از ساخت شیء خودداری کنید؛ اگر نیاز به تنظیم پروتوتایپ دارید، در زمان ایجاد آن این کار را بکنید.
- از پراپرتی‌های مشترک در پروتوتایپ (متدها) و پراپرتی‌های مخصوص هر نمونه در خود شیء بهره ببرید تا حافظه بهینه باشد.
- زمانی که قصد بررسی مالکیت مستقیم دارید، `hasOwnProperty` را به‌جای `in` یا سایر روش‌ها به کار ببرید.

---

با درک عمیق زنجیرهٔ پروتوتایپ، می‌توانید الگوهای قدرتمند وراثت و اشتراک رفتار در برنامه‌های JavaScript خود خلق کنید و با اطمینان بیشتری پیچیدگی‌های این زبان را مدیریت نمایید.
