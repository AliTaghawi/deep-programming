# شاخه‌ها (Conditionals) در JavaScript

جاوااسکریپت با ساختارهای شرطی (Conditionals) به شما امکان می‌دهد جریان اجرای کد را بر اساس ارزیابی عبارت‌ها (expressions) تغییر دهید. دو مکانیزم اصلی برای این کار وجود دارد: `if`/`else` و `switch`/`case`. در ادامه هر یک را از پایه تا عمق بررسی می‌کنیم.

---

## فهرست مطالب

1. مقدمه: چرا شاخه‌ها؟  
2. ساختار if / else  
   - نحو و اجزاء  
   - تبدیل نوع به بولین (ToBoolean)  
   - بلوک‌ها و اسکوپ  
   - مثال‌ها و الگوهای رایج  
3. ساختار switch / case  
   - نحو و جریان اجرا  
   - تطابق با مقایسهٔ سختگیرانه (===)  
   - fall-through و کنترل جریان  
   - caseهای چندگانه و default  
   - بلوک اسکوپی و نکات ویژه  
   - مثال‌ها و الگوهای پیشرفته  
4. مقایسهٔ if vs switch  
5. بهترین شیوه‌ها و نکات عملی  
6. منابع پیشنهادی  

---

## 1. مقدمه: چرا شاخه‌ها؟

شاخه‌ها ابزارهایی برای تصمیم‌گیری در برنامه‌اند:

- اجرای گزینشی قطعه‌ای از کد  
- جلوگیری از تکرار با مدیریت جریان بهینه  
- خواناتر کردن منطق پیچیده  

بدون شرط‌ها، هر بار باید همه عبارات را ارزیابی کنیم که هم ناکارآمد است و هم کد را به هم‌ریختگی می‌کشاند.

---

## 2. ساختار if / else

### 2.1 نحو کلی

```js
if (condition) {
  // بلوک زمانی که condition truthy است
} else if (anotherCondition) {
  // بلوک جایگزین زمانی که شرط دوم برقرار است
} else {
  // بلوک زمانی که هیچ شرطی برقرار نیست
}
```

- شرط‌ها درون پرانتز `()` قرار می‌گیرند.  
- هر بلوک با `{ ... }` تعریف می‌شود.  
- بخش `else if` دلخواه و می‌تواند چندین بار تکرار شود.  
- `else` در پایان اگر هیچ `if` یا `else if` قبلی اجرا نشود، همیشه یک‌بار اجرا می‌شود.

### 2.2 تبدیل نوع به بولین (ToBoolean)

قبل از ارزیابی شرط، JavaScript هر عبارت را به یک مقدار بولین تبدیل می‌کند:

- مقادیر “falsy”: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`  
- هر چیز دیگر “truthy” است (مثلاً `[ ]`, `{ }`, `"0"`, `42`).

```js
if ("")      // false
if ({})      // true
if (NaN)     // false
```

### 2.3 بلوک‌ها و اسکوپ

- متغیرهای تعریف‌شده با `let` / `const` درون هر بلوک جداگانه Scoped هستند:  
  ```js
  if (x) {
    let y = 10;
  }
  console.log(y); // ReferenceError
  ```
- متغیرهای `var` درون تابع یا سطح جهانی Scoped می‌مانند (hoisting).

### 2.4 مثال‌ها و الگوهای رایج

1. **گزینه‌های چندگانه**  
   ```js
   if (score >= 90) {
     grade = "A";
   } else if (score >= 80) {
     grade = "B";
   } else {
     grade = "C";
   }
   ```
2. **Guard Clause**  
   حلقهٔ تو در تو و چک ابتدای تابع برای خروج زودهنگام:
   ```js
   function process(value) {
     if (!value) return;
     // ادامهٔ منطق اصلی
   }
   ```

---

## 3. ساختار switch / case

### 3.1 نحو و جریان اجرا

```js
switch (expression) {
  case value1:
    // بلوک زمانی که expression === value1
    break;
  case value2:
    // بلوک زمانی که expression === value2
    break;
  default:
    // بلوک زمانی که هیچ case قبلی برقرار نیست
}
```

1. `expression` تنها یک‌بار ارزیابی می‌شود.  
2. هر `case` با استفاده از `===` مقایسه می‌شود.  
3. از اولین `case` مطابق تا `break` یا تا انتهای `switch` اجرا ادامه می‌یابد (fall-through).  
4. در صورت نبود تطابق، بلوک `default` اجرا می‌شود (اختیاری).

### 3.2 چند نکتهٔ مهم

- **تطابق سختگیرانه:**  
  ```js
  switch ("5") {
    case 5:  // false، چون "5" !== 5
      ...
  }
  ```
- **fall-through**  
  اگر `break` ننویسید، بلوک‌های بعدی نیز اجرا می‌شوند:
  ```js
  switch (x) {
    case 1:
    case 2:
      console.log("x is 1 or 2");
      break;
  }
  ```
- **default** باید در انتها قرار گیرد تا زمانی که هیچ `case`‌ای پیدا نشود اجرا شود.

### 3.3 بلوک اسکوپی در switch

- `switch` مثل یک بلوک عمل می‌کند؛ بنابراین می‌توانید `let` / `const` داخل هر `case` تعریف کنید، اما باید در بلاک جداگانه باشند:
  ```js
  switch (x) {
    case 1: {
      let a = 10;
      break;
    }
    case 2: {
      let a = 20;
      break;
    }
  }
  ```

### 3.4 مثال‌ها و الگوهای پیشرفته

1. **گروه‌بندی چند case**  
   ```js
   switch (color) {
     case "red":
     case "pink":
       console.log("warm");
       break;
     case "blue":
     case "green":
       console.log("cool");
       break;
   }
   ```
2. **case با عبارت دینامیک**  
   ```js
   const THRESHOLD = 10;
   let level = 7;
   switch (true) {
     case level >= THRESHOLD:
       console.log("high");
       break;
     default:
       console.log("low");
   }
   ```
3. **استفاده از return برای خروج**  
   درون توابع گاهی به جای `break` از `return` استفاده می‌کنیم:
   ```js
   function getType(x) {
     switch (typeof x) {
       case "string": return "متن";
       case "number": return "عدد";
       default: return "نامشخص";
     }
   }
   ```

---

## 4. مقایسهٔ if vs switch

| ویژگی                       | if / else                           | switch / case                      |
|------------------------------|-------------------------------------|------------------------------------|
| مناسب برای                   | شرایط پیچیده با تبدیل نوع و منطق   | مقایسهٔ یک’expression با مقادیر ثابت |
| خوانایی                     | وقتی شرط‌ها پیوسته (chain) باشند   | زمانی که تعدادی case مشخص داریم   |
| اولویت اجرای شرط‌ها         | بالاتر به پایین                     | تنها یک بار ارزیابی expression     |
| fall-through                | ندارد                               | دارد؛ نیاز به `break`             |
| اسکوپ محلی                   | هر بلوک مجزا                       | هر `case` بلاک مجزا                |

---

## 5. بهترین شیوه‌ها و نکات عملی

- برای ساده‌ترین مسیرها از **Guard Clauses** بهره ببرید (خروج زودهنگام).  
- در `if`/`else if` زنجیره‌های بسیار طولانی خوانایی را کاهش می‌دهند؛ در این موارد `switch(true)` یا نگاشت (Object mapping) را در نظر بگیرید.  
- همیشه بعد از هر `case` که قرار نیست fall-through کند از `break` یا `return` استفاده کنید.  
- برای شرط‌های ترکیبی پیچیده در `switch` می‌توانید روی `true` سوییچ کنید و شرط‌ها را در caseها بنویسید.  
- از اسکوپ‌های بلوکی در داخل `case` برای جلوگیری از تداخل نام متغیرها استفاده کنید.  

---

## 6. منابع پیشنهادی

- MDN Web Docs: “Control flow and error handling”  
- MDN Web Docs: “if...else” و “switch”  
- ECMAScript® Language Specification – بخش 13: **Statements and declarations**  
- کتاب **You Don’t Know JS: Up & Going** by Kyle Simpson  

با تسلط بر این دو ساختار، کنترل دقیقی بر جریان اجرای برنامه‌های JavaScript خواهید داشت و می‌توانید منطق‌های پیچیده را به‌صورت خوانا و قابل نگهداری پیاده کنید.
