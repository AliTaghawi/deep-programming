# دلیل تفاوت خروجی var, let در حلقه

در JavaScript متغیرهای `var` و `let` هر یک روش متفاوتی برای نگهداری و بایند کردن مقدار در حلقه‌ها دارند. این تفاوت باعث می‌شود که هنگام استفاده از callbackهای زمان‌دار مثل `setTimeout` نتیجه‌های متفاوتی ببینیم.

---

## متغیر var

در حلقه با `var`:

- متغیر `i` تابع‌محور است و یک نمونه یکتا از آن در کل حلقه وجود دارد.  
- هر بار که callback در صف اجرا قرار می‌گیرد، هنوز حلقه ادامه دارد و در نهایت `i` به ۳ می‌رسد.  
- وقتی زمان اجرای `setTimeout` فرا می‌رسد، مقدار نهایی `i` (یعنی ۳) خوانده می‌شود و سه بار `3` چاپ می‌شود.

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 3 3 3
}
```

---

## متغیر let

در حلقه با `let`:

- متغیر `i` بلوک‌محور است و برای هر بار تکرار حلقه یک بایندینگ جدید ایجاد می‌شود.  
- هر callback به نمونهٔ مربوط به همان تکرار دسترسی دارد.  
- در نتیجه خروجی به‌ترتیب `0`, `1`, `2` خواهد بود.

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 0 1 2
}
```

---

## مقایسه کلی

| ویژگی                    | var                         | let                         |
|---------------------------|-----------------------------|-----------------------------|
| نوع اسکوپ                 | تابع‌محور (function-scope)  | بلوک‌محور (block-scope)     |
| تعداد بایندینگ در حلقه    | یک عدد مشترک               | یک بایندینگ برای هر تکرار   |
| رفتار در closure          | همیشه مقدار نهایی خوانده می‌شود | مقدار مخصوص همان تکرار خوانده می‌شود |

---

## راهکارهای جایگزین برای var

- استفاده از IIFE (تابع خوداجرا) برای قفل کردن مقدار فعلی `i`  
- تعریف تابع کارخانه (factory) که مقدار را در پارامتر بگیرد  
- تبدیل آرایه به متدهای `forEach` یا `map` و استفاده از پارامتر اندیس  

---

در قدم بعدی می‌توانید به مباحثی مثل نحوه کار event loop، صف‌ بندی Callbackها و تفاوت Macro- و Micro-tasks در JavaScript بپردازید تا درک عمیق‌تری از زمان‌بندی توابع در محیط مرورگر پیدا کنید.
